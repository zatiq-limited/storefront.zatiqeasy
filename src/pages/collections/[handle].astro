---
/**
 * ========================================
 * COLLECTION DETAIL PAGE (DYNAMIC)
 * ========================================
 *
 * Backend API Endpoint:
 * GET /api/storefront/v1/collections/:id
 * Returns: { success: true, data: { sections: [...], collection: {...}, products: [...], subcategories: [...] } }
 *
 * Dev Mode: Uses category.json and products.json as fallback
 * URL: /collections/:id where id is the category ID
 */

import Layout from '../../layouts/main.astro';
import CollectionDetailsPageRenderer from '../../components/CollectionDetailsPageRenderer';
import collectionDetailsPageData from '../../data/api-responses/collection-details-page.json';
import categoryData from '../../data/api-responses/category.json';
import productsData from '../../data/api-responses/products.json';

// Enable server-side rendering for dynamic collection pages
export const prerender = false;

// Get handle (ID) from URL
const { handle } = Astro.params;
const categoryId = parseInt(handle || '0', 10);

// Initialize data
let collection: any = null;
let products: any[] = [];
let subcategories: any[] = [];
let sections: any[] = [];

/**
 * Helper function to find a category by ID (searches recursively through all levels)
 * Returns the category with breadcrumb path
 */
function findCategoryById(categories: any[], id: number, path: any[] = []): { category: any; breadcrumb: any[] } | null {
	for (const category of categories) {
		// Current path includes this category
		const currentPath = [...path, { id: category.id, name: category.name }];

		if (category.id === id) {
			return {
				category: { ...category, parent: path.length > 0 ? path[path.length - 1] : null },
				breadcrumb: currentPath
			};
		}

		// Recursively search in children
		if (category.children && category.children.length > 0) {
			const found = findCategoryById(category.children, id, currentPath);
			if (found) {
				return found;
			}
		}
	}
	return null;
}

/**
 * Helper function to map category to collection format
 */
function mapCategoryToCollection(category: any, breadcrumb: any[] = []): any {
	return {
		id: category.id,
		handle: category.name?.toLowerCase().replace(/\s+/g, '-') || `category-${category.id}`,
		category_id: category.id,
		title: category.name,
		subtitle: category.description || '',
		description: category.description || '',
		image: category.image_url,
		banner_url: category.banner_url || category.image_url,
		product_count: category.product_count || 0,
		is_active: true,
		serial: category.serial || 1,
		parent: category.parent || null,
		breadcrumb: breadcrumb, // Array of { id, name } for hierarchical navigation
		created_at: category.created_at,
		updated_at: category.updated_at,
		seo: {
			meta_title: `${category.name} - ZatiqEasy`,
			meta_description: category.description || `Shop ${category.name} products at ZatiqEasy`,
			meta_keywords: category.name?.toLowerCase(),
			og_title: `${category.name} Collection - ZatiqEasy`,
			og_description: category.description || `Discover our ${category.name} collection`,
			og_image: category.banner_url || category.image_url
		}
	};
}

/**
 * Helper function to filter products by category ID
 */
function filterProductsByCategory(allProducts: any[], categoryId: number): any[] {
	return allProducts.filter(product => {
		if (!product.categories || !Array.isArray(product.categories)) {
			return false;
		}
		return product.categories.some((cat: any) => cat.id === categoryId);
	});
}

try {
	const API_BASE_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:3001';

	// Single API call to get everything
	const collectionResponse = await fetch(`${API_BASE_URL}/api/storefront/v1/collections/${categoryId}`);
	const collectionResult = await collectionResponse.json();

	if (collectionResult.success && collectionResult.data) {
		// Extract sections (from API or use default from JSON)
		sections = collectionResult.data.sections || collectionDetailsPageData.data.sections;

		// Extract collection, products, and subcategories
		collection = collectionResult.data.collection;
		products = collectionResult.data.products || [];
		subcategories = collectionResult.data.subcategories || [];
	}
} catch (error) {
	console.error('[Collection Page] API failed:', error);
}

// Fallback to local JSON data if API didn't return collection data
if (!collection) {
	console.log('[Collection Page] Using dev mode data for category:', categoryId);

	// Use default sections from JSON
	sections = collectionDetailsPageData.data.sections;

	// Find category by ID from category.json (returns { category, breadcrumb })
	const result = findCategoryById(categoryData.data.categories, categoryId);

	if (result) {
		const { category, breadcrumb } = result;

		// Map category to collection format with breadcrumb
		collection = mapCategoryToCollection(category, breadcrumb);

		// Get subcategories (children) - ensure they have the same structure as categories
		subcategories = (category.children || []).map((child: any) => ({
			id: child.id,
			name: child.name,
			image_url: child.image_url,
			banner_url: child.banner_url || child.image_url,
			description: child.description || '',
			product_count: child.product_count || 0,
			serial: child.serial || 1,
			parent_id: category.id
		}));

		// Filter products by category ID
		products = filterProductsByCategory(productsData.data.products, categoryId);
	}
}

if (!collection) {
	return Astro.redirect('/404');
}
---

<Layout
	title={collection.seo?.meta_title || `${collection.title} | ZatiqEasy`}
	description={collection.seo?.meta_description || collection.description || collection.subtitle}
	image={collection.seo?.og_image || collection.banner_url || collection.image}
>
	<CollectionDetailsPageRenderer
		sections={sections}
		collection={collection}
		products={products}
		subcategories={subcategories}
		client:load
	/>
</Layout>

<style>
	/* Smooth scrolling */
	html {
		scroll-behavior: smooth;
	}

	/* Line clamp utilities */
	.line-clamp-2 {
		display: -webkit-box;
		-webkit-line-clamp: 2;
		-webkit-box-orient: vertical;
		overflow: hidden;
	}

	.line-clamp-3 {
		display: -webkit-box;
		-webkit-line-clamp: 3;
		-webkit-box-orient: vertical;
		overflow: hidden;
	}
</style>
